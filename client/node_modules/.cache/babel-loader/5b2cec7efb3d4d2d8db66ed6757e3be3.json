{"ast":null,"code":"import { __rest, __assign } from 'tslib';\nimport { isMotionValue } from '../../value/utils/is-motion-value.js';\nimport { isTransformProp } from './utils/transform.js';\nimport { getDefaultValueType } from './utils/value-types.js';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.js';\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.js';\nimport { visualElement } from '../index.js';\nimport { getBoundingBox } from './projection/measure.js';\nimport { isCSSVariable } from './utils/is-css-variable.js';\nimport { buildHTMLStyles } from './utils/build-html-styles.js';\nimport { parseDomVariant } from './utils/parse-dom-variant.js';\n\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n\nvar htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance: function (domElement, key) {\n    if (isTransformProp(key)) {\n      var defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      var computedStyle = getComputedStyle(domElement);\n      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n    }\n  },\n  createRenderState: function () {\n    return {\n      style: {},\n      transform: {},\n      transformKeys: [],\n      transformOrigin: {},\n      vars: {}\n    };\n  },\n  sortNodePosition: function (a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n  getBaseTarget: function (props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n  measureViewportBox: function (element, _a) {\n    var transformPagePoint = _a.transformPagePoint;\n    return getBoundingBox(element, transformPagePoint);\n  },\n\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform: function (element, domElement, props) {\n    /**\n     * When we reset the transform of an element, there's a fair possibility that\n     * the element will visually move from underneath the pointer, triggering attached\n     * pointerenter/leave events. We temporarily suspend these while measurement takes place.\n     */\n    element.suspendHoverEvents();\n    var transformTemplate = props.transformTemplate;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n  restoreTransform: function (instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromMutableState: function (key, _a) {\n    var vars = _a.vars,\n        style = _a.style;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable: function (element, _a, _b, isMounted) {\n    var transformValues = _b.transformValues;\n\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n\n    var transition = _a.transition,\n        transitionEnd = _a.transitionEnd,\n        target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n    var origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      var parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return __assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps: function (props) {\n    var style = props.style;\n    var newValues = {};\n\n    for (var key in style) {\n      if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n        newValues[key] = style[key];\n      }\n    }\n\n    return newValues;\n  },\n  build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate);\n  },\n  render: function (element, _a) {\n    var style = _a.style,\n        vars = _a.vars; // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n\n    Object.assign(element.style, style); // Loop over any CSS variables and assign those.\n\n    for (var key in vars) {\n      element.style.setProperty(key, vars[key]);\n    }\n  }\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":{"version":3,"sources":["/Users/victor/Development/blend/client/node_modules/framer-motion/dist/es/render/dom/html-visual-element.js"],"names":["__rest","__assign","isMotionValue","isTransformProp","getDefaultValueType","getOrigin","checkTargetForNewValues","isForcedMotionValue","visualElement","getBoundingBox","isCSSVariable","buildHTMLStyles","parseDomVariant","getComputedStyle","element","window","htmlConfig","treeType","readValueFromInstance","domElement","key","defaultType","default","computedStyle","getPropertyValue","createRenderState","style","transform","transformKeys","transformOrigin","vars","sortNodePosition","a","b","compareDocumentPosition","getBaseTarget","props","_a","measureViewportBox","transformPagePoint","resetTransform","suspendHoverEvents","transformTemplate","scheduleRender","restoreTransform","instance","mutableState","removeValueFromMutableState","makeTargetAnimatable","_b","isMounted","transformValues","transition","transitionEnd","target","origin","parsed","scrapeMotionValuesFromProps","newValues","build","renderState","latestValues","projection","layoutState","options","isVisible","undefined","visibility","render","Object","assign","setProperty","htmlVisualElement"],"mappings":"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","sourcesContent":["import { __rest, __assign } from 'tslib';\nimport { isMotionValue } from '../../value/utils/is-motion-value.js';\nimport { isTransformProp } from './utils/transform.js';\nimport { getDefaultValueType } from './utils/value-types.js';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.js';\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.js';\nimport { visualElement } from '../index.js';\nimport { getBoundingBox } from './projection/measure.js';\nimport { isCSSVariable } from './utils/is-css-variable.js';\nimport { buildHTMLStyles } from './utils/build-html-styles.js';\nimport { parseDomVariant } from './utils/parse-dom-variant.js';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function (domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            var computedStyle = getComputedStyle(domElement);\n            return ((isCSSVariable(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0);\n        }\n    },\n    createRenderState: function () { return ({\n        style: {},\n        transform: {},\n        transformKeys: [],\n        transformOrigin: {},\n        vars: {},\n    }); },\n    sortNodePosition: function (a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function (props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function (element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return getBoundingBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform: function (element, domElement, props) {\n        /**\n         * When we reset the transform of an element, there's a fair possibility that\n         * the element will visually move from underneath the pointer, triggering attached\n         * pointerenter/leave events. We temporarily suspend these while measurement takes place.\n         */\n        element.suspendHoverEvents();\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function (instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromMutableState: function (key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return __assign({ transition: transition,\n            transitionEnd: transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps: function (props) {\n        var style = props.style;\n        var newValues = {};\n        for (var key in style) {\n            if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n                newValues[key] = style[key];\n            }\n        }\n        return newValues;\n    },\n    build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate);\n    },\n    render: function (element, _a) {\n        var style = _a.style, vars = _a.vars;\n        // Directly assign style into the Element's style prop. In tests Object.assign is the\n        // fastest way to assign styles.\n        Object.assign(element.style, style);\n        // Loop over any CSS variables and assign those.\n        for (var key in vars) {\n            element.style.setProperty(key, vars[key]);\n        }\n    },\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\nexport { getComputedStyle, htmlConfig, htmlVisualElement };\n"]},"metadata":{},"sourceType":"module"}