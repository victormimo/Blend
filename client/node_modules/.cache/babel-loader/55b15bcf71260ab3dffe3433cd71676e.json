{"ast":null,"code":"import { __extends, __rest, __read, __assign } from 'tslib';\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { startAnimation } from '../../../animation/utils/transitions.js';\nimport { Component, createElement } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\nimport { tweenAxis } from './utils.js';\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  __extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n    _this.isAnimatingTree = false;\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          shouldStackAnimate = _a.shouldStackAnimate,\n          onComplete = _a.onComplete,\n          config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\n       * Early return if we've been instructed not to animate this render.\n       */\n\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      /**\n       * Prioritise tree animations\n       */\n\n\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], config);\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.syncRender();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n\n      return Promise.all(animations).then(function () {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement.notifyLayoutAnimationComplete();\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var visualElement = this.props.visualElement;\n    visualElement.animateMotionValue = startAnimation;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n\n    visualElement.layoutSafeToRemove = function () {\n      return _this.safeToRemove();\n    };\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _b, _c;\n\n    var transition = (_a === void 0 ? {} : _a).transition;\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Ensure that the layout delta is updated for this frame.\n\n    visualElement.updateLayoutProjection(); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame); // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition).then(unsubscribeProgress);\n\n    this.stopAxisAnimation[axis] = function () {\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    return animation;\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(Component);\n\nfunction AnimateLayoutContextProvider(props) {\n  var _a = __read(usePresence(), 2),\n      safeToRemove = _a[1];\n\n  return createElement(Animate, __assign({}, props, {\n    safeToRemove: safeToRemove\n  }));\n}\n\nfunction hasMoved(a, b) {\n  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));\n}\n\nvar zeroAxis = {\n  min: 0,\n  max: 0\n};\n\nfunction isZeroBox(a) {\n  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\n\nfunction axisIsEqual(a, b) {\n  return a.min === b.min && a.max === b.max;\n}\n\nvar defaultTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n/**\n * @public\n */\n\nvar AnimateLayout = {\n  key: \"animate-layout\",\n  shouldRender: function (props) {\n    return !!props.layout || props.layoutId !== undefined;\n  },\n  getComponent: function () {\n    return AnimateLayoutContextProvider;\n  }\n};\nexport { AnimateLayout };","map":{"version":3,"sources":["/Users/victor/Development/blend/client/node_modules/framer-motion/dist/es/motion/features/layout/Animate.js"],"names":["__extends","__rest","__read","__assign","VisibilityAction","eachAxis","startAnimation","Component","createElement","usePresence","tweenAxis","progressTarget","Animate","_super","_this","apply","arguments","frameTarget","x","min","max","y","stopAxisAnimation","undefined","isAnimatingTree","animate","target","origin","_a","originBox","targetBox","visibilityAction","shouldStackAnimate","onComplete","config","_b","props","visualElement","layout","safeToRemove","boxHasMoved","hasMoved","animations","axis","targetLength","projection","isTargetLocked","setVisibility","Show","animateAxis","setProjectionTargetAxis","syncRender","Promise","all","then","notifyLayoutAnimationComplete","prototype","componentDidMount","animateMotionValue","enableLayoutProjection","unsubLayoutReady","onLayoutUpdate","layoutSafeToRemove","componentWillUnmount","call","_c","transition","layoutProgress","getProjectionAnimationProgress","clearListeners","set","frame","p","get","updateLayoutProjection","unsubscribeProgress","onChange","animation","defaultTransition","stop","render","AnimateLayoutContextProvider","a","b","isZeroBox","axisIsEqual","zeroAxis","duration","ease","AnimateLayout","key","shouldRender","layoutId","getComponent"],"mappings":"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","sourcesContent":["import { __extends, __rest, __read, __assign } from 'tslib';\nimport { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { startAnimation } from '../../../animation/utils/transitions.js';\nimport { Component, createElement } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.js';\nimport { tweenAxis } from './utils.js';\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    __extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.frameTarget = {\n            x: { min: 0, max: 0 },\n            y: { min: 0, max: 0 },\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], config);\n                }\n                else {\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _b, _c;\n        var transition = (_a === void 0 ? {} : _a).transition;\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Ensure that the layout delta is updated for this frame.\n        visualElement.updateLayoutProjection();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition).then(unsubscribeProgress);\n        this.stopAxisAnimation[axis] = function () {\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = __read(usePresence(), 2), safeToRemove = _a[1];\n    return createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\n/**\n * @public\n */\nvar AnimateLayout = {\n    key: \"animate-layout\",\n    shouldRender: function (props) {\n        return !!props.layout || props.layoutId !== undefined;\n    },\n    getComponent: function () { return AnimateLayoutContextProvider; },\n};\n\nexport { AnimateLayout };\n"]},"metadata":{},"sourceType":"module"}