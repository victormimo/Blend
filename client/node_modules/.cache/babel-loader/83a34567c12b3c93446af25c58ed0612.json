{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar difference = require('../').difference;\n\nvar flatMap = require('../').flatMap;\n\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\n\nvar RTCP_BITRATE = 16000;\n/**\n * Construct a b= line string for the given max bitrate in bps. If the modifier\n * is 'AS', then the max bitrate will be converted to kbps using the formula\n * specified in the IETF spec for JSEP mentioned above.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\n *   otherwise return the constructed b= line string\n */\n\nfunction createBLine(modifier, maxBitrate) {\n  if (!maxBitrate) {\n    return null;\n  }\n\n  return '\\r\\nb=' + modifier + ':' + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\n}\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\n\n\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\n\n\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\n\n\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\n\n\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp('^a=fmtp:' + pt + ' (.+)$', 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _nvPair$split = nvPair.split('='),\n        _nvPair$split2 = _slicedToArray(_nvPair$split, 2),\n        name = _nvPair$split2[0],\n        value = _nvPair$split2[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\n\n\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\n\n\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0]; // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n\n  var matches = mLine.match(/([0-9]+)/g); // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n\n  if (!matches) {\n    return [];\n  } // Since only the Payload Types are needed, we discard the <port>.\n\n\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\n\n\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (_ref) {\n    var codec = _ref.codec;\n    return codec.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the specified max bitrate in the given m= section.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @param {string} section - m= section string\n * @returns {string} The updated m= section\n */\n\n\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n  var bLine = createBLine(modifier, maxBitrate) || '';\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n  var bLineMatched = section.match(bLinePattern);\n\n  if (!bLineMatched) {\n    return section.replace(/(\\r\\n)?$/, bLine + '$1');\n  }\n\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n  maxBitrate = maxBitrate || Infinity;\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n  return section.replace(bLinePattern, bLine);\n}\n/**\n * Set maximum bitrates to the media sections in a given sdp.\n * @param {string} sdp - sdp string\n * @param {string} modifier - 'AS' | 'TIAS\"\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\n *   if no limit is to be applied\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\n *   if no limit is to be applied\n * @returns {string} - The updated sdp string\n */\n\n\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Bitrate parameters should not be applied to m=application sections\n    // or to m=(audio|video) sections that do not receive media.\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\n  })).join('\\r\\n');\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\n\n\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\n\n\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {'planb' | 'unified'} sdpFormat\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\n\n\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Get the matching Payload Types in a unified plan local m= section for a particular remote codec.\n * @param {Codec} remoteCodec\n * @param {PT} remotePt\n * @param {Map<Codec, PT>} localCodecsToPts\n * @param {string} localSection\n * @param {string} remoteSection\n * @returns {Array<PT>}\n */\n\n\nfunction unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingLocalPts = localCodecsToPts.get(remoteCodec) || [];\n\n  if (matchingLocalPts.length <= 1) {\n    return matchingLocalPts;\n  } // If there are no fmtp attributes for the codec in the remote m= section,\n  // then we cannot get a match in the local m= section. In that case, retain\n  // all matching local Payload Types.\n\n\n  var remoteFmtpAttrs = getFmtpAttributesForPt(remotePt, remoteSection);\n\n  if (!remoteFmtpAttrs) {\n    return matchingLocalPts;\n  } // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n\n\n  var matchinglocalPt = matchingLocalPts.find(function (localPt) {\n    var localFmtpAttrs = getFmtpAttributesForPt(localPt, localSection);\n    return localFmtpAttrs && Object.keys(remoteFmtpAttrs).every(function (attr) {\n      return remoteFmtpAttrs[attr] === localFmtpAttrs[attr];\n    });\n  }); // If none of the matched local Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the local Payload Type that\n  // matches the remote fmtp attributes.\n\n  return typeof matchinglocalPt === 'number' ? [matchinglocalPt] : matchingLocalPts;\n}\n/**\n * Filter codecs in a local unified plan m= section based on its equivalent remote m= section.\n * @param {string} localSection\n * @param {Map<string, string>} remoteMidsToMediaSections\n * @returns {string}\n */\n\n\nfunction unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections) {\n  // Do nothing if the local m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(localSection)) {\n    return localSection;\n  } // Do nothing if the local m= section does not have an equivalent remote m= section.\n\n\n  var localMid = getMidForMediaSection(localSection);\n  var remoteSection = localMid && remoteMidsToMediaSections.get(localMid);\n\n  if (!remoteSection) {\n    return localSection;\n  } // Construct a Map of the remote Payload Types to their codec names.\n\n\n  var remotePtToCodecs = createPtToCodecName(remoteSection); // Construct a Map of the local codec names to their Payload Types.\n\n  var localCodecsToPts = createCodecMapForMediaSection(localSection); // Maintain a list of local non-rtx Payload Types to retain.\n\n  var localPts = flatMap(Array.from(remotePtToCodecs), function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        remotePt = _ref3[0],\n        remoteCodec = _ref3[1];\n\n    return remoteCodec !== 'rtx' ? unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) : [];\n  }); // For each local Payload Type that will be retained, retain their\n  // corresponding rtx Payload Type if present.\n\n  var localRtxPts = localCodecsToPts.get('rtx') || []; // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n\n  localPts = localPts.concat(localRtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, localSection);\n    return fmtpAttrs && localPts.includes(fmtpAttrs.apt);\n  })); // Filter out the below mentioned attribute lines in the local m= section that\n  // do not belong to one of the local Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n\n  var lines = localSection.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && localPts.includes(parseInt(pt, 10));\n  }); // Filter the list of Payload Types in the first line of the m= section.\n\n  var orderedLocalPts = getPayloadTypesInMediaSection(localSection).filter(function (pt) {\n    return localPts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedLocalPts, lines.join('\\r\\n'));\n}\n/**\n * Filter local codecs based on the remote unified plan SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\n\n\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections);\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @return {string} Updated SDP string\n */\n\n\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n  })).concat('').join('\\r\\n');\n}\n/**\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\n * corresponding local MediaStreamTrack IDs. These can be different when previously\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\n * SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\n\n\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        kind = _ref5[0],\n        trackIds = _ref5[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\n\n\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n\n\n    var mid = getMidForMediaSection(mediaSection);\n\n    if (!mid) {\n      return mediaSection;\n    } // In case there is no Track ID for the given MID in the map, do nothing.\n\n\n    var trackId = midsToTrackIds.get(mid);\n\n    if (!trackId) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n\n\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n\n    if (!attributes) {\n      return mediaSection;\n    } // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n\n    var _attributes$split = attributes.split(' '),\n        _attributes$split2 = _slicedToArray(_attributes$split, 2),\n        msid = _attributes$split2[0],\n        trackIdToRewrite = _attributes$split2[1];\n\n    var msidRegex = new RegExp('msid:' + msid + (trackIdToRewrite ? ' ' + trackIdToRewrite : '') + '$', 'gm');\n    return mediaSection.replace(msidRegex, 'msid:' + msid + ' ' + trackId);\n  })).join('\\r\\n');\n}\n/**\n * removes specified ssrc attributes from given sdp\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\n\n\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(function (line) {\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\n    });\n  }).join('\\r\\n');\n}\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\n\n\nfunction disableRtx(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    } // Create a map of codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(mediaSection); // Get the RTX payload types.\n\n    var rtxPts = codecsToPts.get('rtx'); // Do nothing if there are no RTX payload types.\n\n    if (!rtxPts) {\n      return mediaSection;\n    } // Remove the RTX payload types.\n\n\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(function (rtxPt) {\n      return pts.delete(rtxPt);\n    }); // Get the RTX SSRC.\n\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1]; // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp('^a=ssrc:' + rtxSSRC + ' .+$')] : []);\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\n      return filterRegexes.every(function (regex) {\n        return !regex.test(line);\n      });\n    }).join('\\r\\n'); // Reconstruct the m= section without the RTX payload types.\n\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\n\n\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        name = _ref7[0],\n        value = _ref7[1];\n\n    return name + '=' + value;\n  }).join(';');\n  return 'a=fmtp:' + pt + ' ' + serializedFmtpAttrs;\n}\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\n\n\nfunction enableDtxForOpus(sdp, mids) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  mids = mids || mediaSections.filter(function (section) {\n    return /^m=audio/.test(section);\n  }).map(getMidForMediaSection);\n  return [session].concat(mediaSections.map(function (section) {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    } // Build a map codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(section); // Do nothing if a payload type for opus does not exist.\n\n    var opusPt = codecsToPts.get('opus');\n\n    if (!opusPt) {\n      return section;\n    } // If no fmtp attributes are found for opus, do nothing.\n\n\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n\n    if (!opusFmtpAttrs) {\n      return section;\n    } // Add usedtx=1 to the a=fmtp: line for opus.\n\n\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine); // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n\n    var mid = getMidForMediaSection(section);\n\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;","map":{"version":3,"sources":["/Users/victor/Development/blend/client/node_modules/twilio-video/es5/util/sdp/index.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","difference","require","flatMap","setSimulcastInMediaSection","ptToFixedBitrateAudioCodecName","RTCP_BITRATE","createBLine","modifier","maxBitrate","Math","round","createCodecMapForMediaSection","section","from","createPtToCodecName","reduce","codecMap","pair","pt","codecName","pts","get","set","concat","Map","createMidToMediaSectionMap","sdp","getMediaSections","midsToMediaSections","mediaSection","mid","getMidForMediaSection","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","RegExp","matches","match","toLowerCase","getFmtpAttributesForPt","fmtpRegex","split","attrs","nvPair","_nvPair$split","_nvPair$split2","name","isNaN","parseInt","midMatches","kind","direction","replace","slice","map","filter","kindPattern","directionPattern","test","mLine","getReorderedPayloadTypes","preferredCodecs","_ref","codec","preferredPayloadTypes","remainingCodecs","keys","remainingPayloadTypes","setBitrateInMediaSection","bLine","bLinePattern","bLineMatched","maxBitrateMatched","Infinity","min","setBitrateParameters","maxAudioBitrate","maxVideoBitrate","mediaSections","session","join","setPayloadTypesInMediaSection","payloadTypes","lines","otherLines","setCodecPreferences","preferredAudioCodecs","preferredVideoCodecs","newSection","pcmaPayloadTypes","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","setSimulcast","sdpFormat","trackIdsToAttributes","vp8PayloadTypes","hasVP8PayloadType","some","payloadType","unifiedPlanGetMatchingLocalPayloadTypes","remoteCodec","remotePt","localCodecsToPts","localSection","remoteSection","matchingLocalPts","remoteFmtpAttrs","matchinglocalPt","find","localPt","localFmtpAttrs","every","attr","unifiedPlanFilterCodecsInLocalMediaSection","remoteMidsToMediaSections","localMid","remotePtToCodecs","localPts","_ref2","_ref3","localRtxPts","rtxPt","fmtpAttrs","includes","apt","line","ptMatches","orderedLocalPts","unifiedPlanFilterLocalCodecs","localSdp","remoteSdp","localMediaSections","localSession","revertSimulcastForNonVP8MediaSections","localSdpWithoutSimulcast","remoteMidToMediaSections","localMidToMediaSectionsWithoutSimulcast","remotePayloadTypes","isVP8ThePreferredCodec","unifiedPlanAddOrRewriteNewTrackIds","activeMidsToTrackIds","trackIdsByKind","newMidsToTrackIds","midsToTrackIds","_ref4","_ref5","trackIds","newMids","forEach","unifiedPlanAddOrRewriteTrackIds","trackId","attributes","_attributes$split","_attributes$split2","msid","trackIdToRewrite","msidRegex","removeSSRCAttributes","ssrcAttributesToRemove","srcAttribute","disableRtx","codecsToPts","rtxPts","delete","rtxSSRCMatches","rtxSSRC","filterRegexes","regex","generateFmtpLineFromPtAndAttributes","serializedFmtpAttrs","entries","_ref6","_ref7","enableDtxForOpus","mids","opusPt","opusFmtpAttrs","origOpusFmtpLine","origOpusFmtpRegex","usedtx","opusFmtpLineWithDtx","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar difference = require('../').difference;\nvar flatMap = require('../').flatMap;\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\nvar RTCP_BITRATE = 16000;\n\n/**\n * Construct a b= line string for the given max bitrate in bps. If the modifier\n * is 'AS', then the max bitrate will be converted to kbps using the formula\n * specified in the IETF spec for JSEP mentioned above.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\n *   otherwise return the constructed b= line string\n */\nfunction createBLine(modifier, maxBitrate) {\n  if (!maxBitrate) {\n    return null;\n  }\n  return '\\r\\nb=' + modifier + ':' + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp('^a=fmtp:' + pt + ' (.+)$', 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _nvPair$split = nvPair.split('='),\n        _nvPair$split2 = _slicedToArray(_nvPair$split, 2),\n        name = _nvPair$split2[0],\n        value = _nvPair$split2[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n  var matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the Payload Types are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (_ref) {\n    var codec = _ref.codec;\n    return codec.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the specified max bitrate in the given m= section.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @param {string} section - m= section string\n * @returns {string} The updated m= section\n */\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n  var bLine = createBLine(modifier, maxBitrate) || '';\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n  var bLineMatched = section.match(bLinePattern);\n\n  if (!bLineMatched) {\n    return section.replace(/(\\r\\n)?$/, bLine + '$1');\n  }\n\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n  maxBitrate = maxBitrate || Infinity;\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n  return section.replace(bLinePattern, bLine);\n}\n\n/**\n * Set maximum bitrates to the media sections in a given sdp.\n * @param {string} sdp - sdp string\n * @param {string} modifier - 'AS' | 'TIAS\"\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\n *   if no limit is to be applied\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\n *   if no limit is to be applied\n * @returns {string} - The updated sdp string\n */\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Bitrate parameters should not be applied to m=application sections\n    // or to m=(audio|video) sections that do not receive media.\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\n  })).join('\\r\\n');\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {'planb' | 'unified'} sdpFormat\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Get the matching Payload Types in a unified plan local m= section for a particular remote codec.\n * @param {Codec} remoteCodec\n * @param {PT} remotePt\n * @param {Map<Codec, PT>} localCodecsToPts\n * @param {string} localSection\n * @param {string} remoteSection\n * @returns {Array<PT>}\n */\nfunction unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingLocalPts = localCodecsToPts.get(remoteCodec) || [];\n  if (matchingLocalPts.length <= 1) {\n    return matchingLocalPts;\n  }\n\n  // If there are no fmtp attributes for the codec in the remote m= section,\n  // then we cannot get a match in the local m= section. In that case, retain\n  // all matching local Payload Types.\n  var remoteFmtpAttrs = getFmtpAttributesForPt(remotePt, remoteSection);\n  if (!remoteFmtpAttrs) {\n    return matchingLocalPts;\n  }\n\n  // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n  var matchinglocalPt = matchingLocalPts.find(function (localPt) {\n    var localFmtpAttrs = getFmtpAttributesForPt(localPt, localSection);\n    return localFmtpAttrs && Object.keys(remoteFmtpAttrs).every(function (attr) {\n      return remoteFmtpAttrs[attr] === localFmtpAttrs[attr];\n    });\n  });\n\n  // If none of the matched local Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the local Payload Type that\n  // matches the remote fmtp attributes.\n  return typeof matchinglocalPt === 'number' ? [matchinglocalPt] : matchingLocalPts;\n}\n\n/**\n * Filter codecs in a local unified plan m= section based on its equivalent remote m= section.\n * @param {string} localSection\n * @param {Map<string, string>} remoteMidsToMediaSections\n * @returns {string}\n */\nfunction unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections) {\n  // Do nothing if the local m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(localSection)) {\n    return localSection;\n  }\n\n  // Do nothing if the local m= section does not have an equivalent remote m= section.\n  var localMid = getMidForMediaSection(localSection);\n  var remoteSection = localMid && remoteMidsToMediaSections.get(localMid);\n  if (!remoteSection) {\n    return localSection;\n  }\n\n  // Construct a Map of the remote Payload Types to their codec names.\n  var remotePtToCodecs = createPtToCodecName(remoteSection);\n  // Construct a Map of the local codec names to their Payload Types.\n  var localCodecsToPts = createCodecMapForMediaSection(localSection);\n  // Maintain a list of local non-rtx Payload Types to retain.\n  var localPts = flatMap(Array.from(remotePtToCodecs), function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        remotePt = _ref3[0],\n        remoteCodec = _ref3[1];\n\n    return remoteCodec !== 'rtx' ? unifiedPlanGetMatchingLocalPayloadTypes(remoteCodec, remotePt, localCodecsToPts, localSection, remoteSection) : [];\n  });\n\n  // For each local Payload Type that will be retained, retain their\n  // corresponding rtx Payload Type if present.\n  var localRtxPts = localCodecsToPts.get('rtx') || [];\n  // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n  localPts = localPts.concat(localRtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, localSection);\n    return fmtpAttrs && localPts.includes(fmtpAttrs.apt);\n  }));\n\n  // Filter out the below mentioned attribute lines in the local m= section that\n  // do not belong to one of the local Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n  var lines = localSection.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && localPts.includes(parseInt(pt, 10));\n  });\n\n  // Filter the list of Payload Types in the first line of the m= section.\n  var orderedLocalPts = getPayloadTypesInMediaSection(localSection).filter(function (pt) {\n    return localPts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedLocalPts, lines.join('\\r\\n'));\n}\n\n/**\n * Filter local codecs based on the remote unified plan SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return unifiedPlanFilterCodecsInLocalMediaSection(localSection, remoteMidsToMediaSections);\n  })).join('\\r\\n');\n}\n\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @return {string} Updated SDP string\n */\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n  })).concat('').join('\\r\\n');\n}\n\n/**\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\n * corresponding local MediaStreamTrack IDs. These can be different when previously\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\n * SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        kind = _ref5[0],\n        trackIds = _ref5[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n\n/**\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n    var mid = getMidForMediaSection(mediaSection);\n    if (!mid) {\n      return mediaSection;\n    }\n    // In case there is no Track ID for the given MID in the map, do nothing.\n    var trackId = midsToTrackIds.get(mid);\n    if (!trackId) {\n      return mediaSection;\n    }\n    // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n    if (!attributes) {\n      return mediaSection;\n    }\n    // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n    var _attributes$split = attributes.split(' '),\n        _attributes$split2 = _slicedToArray(_attributes$split, 2),\n        msid = _attributes$split2[0],\n        trackIdToRewrite = _attributes$split2[1];\n\n    var msidRegex = new RegExp('msid:' + msid + (trackIdToRewrite ? ' ' + trackIdToRewrite : '') + '$', 'gm');\n    return mediaSection.replace(msidRegex, 'msid:' + msid + ' ' + trackId);\n  })).join('\\r\\n');\n}\n\n/**\n * removes specified ssrc attributes from given sdp\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(function (line) {\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\n    });\n  }).join('\\r\\n');\n}\n\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\nfunction disableRtx(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    }\n\n    // Create a map of codecs to payload types.\n    var codecsToPts = createCodecMapForMediaSection(mediaSection);\n    // Get the RTX payload types.\n    var rtxPts = codecsToPts.get('rtx');\n\n    // Do nothing if there are no RTX payload types.\n    if (!rtxPts) {\n      return mediaSection;\n    }\n\n    // Remove the RTX payload types.\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(function (rtxPt) {\n      return pts.delete(rtxPt);\n    });\n\n    // Get the RTX SSRC.\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];\n\n    // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp('^a=ssrc:' + rtxSSRC + ' .+$')] : []);\n\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\n      return filterRegexes.every(function (regex) {\n        return !regex.test(line);\n      });\n    }).join('\\r\\n');\n\n    // Reconstruct the m= section without the RTX payload types.\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        name = _ref7[0],\n        value = _ref7[1];\n\n    return name + '=' + value;\n  }).join(';');\n  return 'a=fmtp:' + pt + ' ' + serializedFmtpAttrs;\n}\n\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\nfunction enableDtxForOpus(sdp, mids) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n\n  mids = mids || mediaSections.filter(function (section) {\n    return (/^m=audio/.test(section)\n    );\n  }).map(getMidForMediaSection);\n\n  return [session].concat(mediaSections.map(function (section) {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    }\n\n    // Build a map codecs to payload types.\n    var codecsToPts = createCodecMapForMediaSection(section);\n\n    // Do nothing if a payload type for opus does not exist.\n    var opusPt = codecsToPts.get('opus');\n    if (!opusPt) {\n      return section;\n    }\n\n    // If no fmtp attributes are found for opus, do nothing.\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n    if (!opusFmtpAttrs) {\n      return section;\n    }\n\n    // Add usedtx=1 to the a=fmtp: line for opus.\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine);\n\n    // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n    var mid = getMidForMediaSection(section);\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;"]},"metadata":{},"sourceType":"script"}